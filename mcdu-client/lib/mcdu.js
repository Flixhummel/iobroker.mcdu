/**
 * MCDU Driver - unified node-hid backend (Mac + Linux)
 *
 * node-hid uses platform-native HID APIs:
 * - Mac: IOHIDManager → IOHIDDeviceSetReport() (control transfers)
 * - Linux: hidraw → kernel sends SET_REPORT control transfers for output reports
 *
 * Both paths result in the SET_REPORT control transfers the WinWing firmware requires.
 */

const PAGE_LINES = 14;
const PAGE_CHARS_PER_LINE = 24;

const VENDOR_ID = 0x4098;
const PRODUCT_ID = 0xbb36;

const COLORS = {
    'L': 0x0000,
    'A': 0x0021,
    'W': 0x0042,
    'B': 0x0063,
    'G': 0x0084,
    'M': 0x00A5,
    'R': 0x00C6,
    'Y': 0x00E7,
    'E': 0x0108,
};

const LEDS = {
    BACKLIGHT: 0,
    SCREEN_BACKLIGHT: 1,
    FAIL: 8,
    FM: 9,
    MCDU: 10,
    MENU: 11,
    FM1: 12,
    IND: 13,
    RDY: 14,
    STATUS: 15,
    FM2: 16,
};

const INIT_PACKETS = [
    [0xf0, 0x0, 0x1, 0x38, 0x32, 0xbb, 0x0, 0x0, 0x1e, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x18, 0x0, 0xe, 0x0, 0x18, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x1, 0x0, 0x6, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x3, 0x38, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0xff, 0xff, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0x0, 0xff, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x5, 0x38, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0x63, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x6, 0x38, 0xff, 0xff, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x7, 0x38, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x42, 0x5c, 0x61, 0xff, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x8, 0x38, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x77, 0x77, 0x77, 0xff, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e, 0x73, 0x79, 0xff, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x9, 0x38, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x20, 0x20, 0x20, 0xff, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xa, 0x38, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0xff, 0xff, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xb, 0x38, 0xff, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xc, 0x38, 0x0, 0x3, 0x0, 0xff, 0x63, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0xff, 0xff, 0x15, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xd, 0x38, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xff, 0xff, 0xff, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x42, 0x5c, 0x61, 0xff, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xe, 0x38, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x77, 0x77, 0x77, 0xff, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x5e, 0x73, 0x79, 0xff, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0xf, 0x38, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x10, 0x38, 0x1b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
    [0xf0, 0x0, 0x11, 0x12, 0x2, 0x32, 0xbb, 0x0, 0x0, 0x1c, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
];

class MCDU {
    constructor() {
        this._hidDevice = null;
        this._buttonPollInterval = null;
        this.buttonCallback = null;
        this._previouslyPressed = new Set();
        this.page = this._createEmptyPage();
        this.colors = this._createEmptyColorBuffer();
    }

    _createEmptyColorBuffer() {
        const buf = [];
        for (let i = 0; i < PAGE_LINES; i++) buf.push(Array(PAGE_CHARS_PER_LINE).fill('W'));
        return buf;
    }

    _createEmptyPage() {
        const page = [];
        for (let i = 0; i < PAGE_LINES; i++) page.push(' '.repeat(PAGE_CHARS_PER_LINE));
        return page;
    }

    // -------------------------------------------------------------------------
    // Connection
    // -------------------------------------------------------------------------

    connect() {
        try {
            const HID = require('node-hid');
            this._hidDevice = new HID.HID(VENDOR_ID, PRODUCT_ID);
            console.log(`✓ Connected (node-hid on ${process.platform})`);
            return true;
        } catch (err) {
            console.error('✗ Connect failed:', err.message);
            return false;
        }
    }

    // -------------------------------------------------------------------------
    // Low-level write (node-hid, synchronous on all platforms)
    // -------------------------------------------------------------------------

    _write(packet) {
        if (!this._hidDevice) {
            console.error('[HID] write skipped — no device handle');
            return;
        }
        const buf = Buffer.from(packet);
        console.log(`[HID] write ${buf.length}B  reportId=0x${buf[0].toString(16).padStart(2,'0')}  first8=${buf.slice(0,8).toString('hex')}`);
        let result;
        try {
            result = this._hidDevice.write(buf);
        } catch (err) {
            console.error(`[HID] write FAILED  reportId=0x${buf[0].toString(16).padStart(2,'0')}  error=${err.message}`);
            console.error('[HID] write error stack:', err.stack);
            throw err;
        }
        if (result !== buf.length) {
            console.error(`[HID] write short: expected ${buf.length}B, got ${result}B`);
        }
        console.log(`[HID] write result: ${result}`);
    }

    // -------------------------------------------------------------------------
    // Display
    // -------------------------------------------------------------------------

    initDisplay() {
        console.log(`[INIT] Starting display init — ${INIT_PACKETS.length} packets`);
        for (let i = 0; i < INIT_PACKETS.length; i++) {
            console.log(`[INIT] Sending packet ${i + 1}/${INIT_PACKETS.length}`);
            this._write(INIT_PACKETS[i]);
            this._sleepMs(10);
            console.log(`[INIT] Packet ${i + 1} done`);
        }
        console.log('✓ Display initialized');
    }

    updateDisplay() {
        const tmpArray = [];
        for (let lineIdx = 0; lineIdx < this.page.length; lineIdx++) {
            const line = this.page[lineIdx];
            for (let charIdx = 0; charIdx < PAGE_CHARS_PER_LINE; charIdx++) {
                const colorCode = COLORS[this.colors[lineIdx][charIdx]] || COLORS.W;
                const char = line[charIdx] || ' ';
                const charCode = char.charCodeAt(0);
                // Multi-byte UTF-8 characters (degree, arrows, etc.) — firmware supports them natively
                if (charCode > 0x7F) {
                    const utf8Bytes = Buffer.from(char, 'utf8');
                    tmpArray.push(colorCode & 0xFF, (colorCode >> 8) & 0xFF, ...utf8Bytes);
                } else {
                    tmpArray.push(colorCode & 0xFF, (colorCode >> 8) & 0xFF, charCode);
                }
            }
        }
        // Pad to multiple of 63
        const padLength = Math.ceil(tmpArray.length / 63) * 63 - tmpArray.length;
        for (let i = 0; i < padLength; i++) tmpArray.push(0x00);

        const totalPackets = tmpArray.length / 63;
        console.log(`[DISPLAY] updateDisplay — ${totalPackets} packets, line0: "${this.page[0] ? this.page[0].trim() : ''}"`);
        for (let i = 0; i < tmpArray.length; i += 63) {
            const pktNum = i / 63 + 1;
            console.log(`[DISPLAY] packet ${pktNum}/${totalPackets}`);
            try {
                this._write([0xf2, ...tmpArray.slice(i, i + 63)]);
            } catch (err) {
                console.error(`[DISPLAY] packet ${pktNum}/${totalPackets} FAILED: ${err.message}`);
                throw err;
            }
            this._sleepMs(40);
        }
        console.log('[DISPLAY] updateDisplay done');
    }

    _sleepMs(ms) {
        const end = Date.now() + ms;
        while (Date.now() < end) { /* busy-wait */ }
    }

    clear() {
        this.page = this._createEmptyPage();
        this.colors = this._createEmptyColorBuffer();
        return this.updateDisplay();
    }

    // -------------------------------------------------------------------------
    // ASCII sanitization
    // -------------------------------------------------------------------------

    /**
     * Replace unsupported non-ASCII characters with ASCII equivalents.
     * WinWing firmware supports a limited set of multi-byte UTF-8 characters:
     * °, Δ, ←, ↑, →, ↓, ▶, ◀, □, ◇
     * All other non-ASCII is replaced to prevent display frame drops.
     */
    sanitizeAscii(text) {
        return text
            .replace(/[äàáâãåÄÀÁÂÃÅ]/g, c => c === c.toUpperCase() ? 'A' : 'a')
            .replace(/[éèêëÉÈÊË]/g, c => c === c.toUpperCase() ? 'E' : 'e')
            .replace(/[íìîïÍÌÎÏ]/g, c => c === c.toUpperCase() ? 'I' : 'i')
            .replace(/[öóòôõÖÓÒÔÕ]/g, c => c === c.toUpperCase() ? 'O' : 'o')
            .replace(/[üúùûÜÚÙÛ]/g, c => c === c.toUpperCase() ? 'U' : 'u')
            .replace(/ß/g, 'ss')
            .replace(/[^\x00-\x7F°Δ←↑→↓▶◀□◇]/g, '?');
    }

    // -------------------------------------------------------------------------
    // Lines / colors
    // -------------------------------------------------------------------------

    setLine(lineNum, textOrSegments, color = 'W') {
        if (lineNum < 0 || lineNum >= PAGE_LINES) return;
        if (Array.isArray(textOrSegments)) {
            this._setLineSegments(lineNum, textOrSegments);
        } else {
            const sanitized = this.sanitizeAscii(textOrSegments);
            const padded = (sanitized + ' '.repeat(PAGE_CHARS_PER_LINE)).substring(0, PAGE_CHARS_PER_LINE);
            this.page[lineNum] = padded;
            const c = this._normalizeColor(color);
            for (let i = 0; i < PAGE_CHARS_PER_LINE; i++) this.colors[lineNum][i] = c;
        }
    }

    _setLineSegments(lineNum, segments) {
        let text = '';
        let charIdx = 0;
        for (const seg of segments) {
            const t = this.sanitizeAscii(seg.text || '');
            const c = this._normalizeColor(seg.color || 'W');
            for (let i = 0; i < t.length && charIdx < PAGE_CHARS_PER_LINE; i++) {
                text += t[i];
                this.colors[lineNum][charIdx++] = c;
            }
        }
        while (charIdx < PAGE_CHARS_PER_LINE) {
            text += ' ';
            this.colors[lineNum][charIdx++] = 'W';
        }
        this.page[lineNum] = text;
    }

    _normalizeColor(color) {
        const map = { white: 'W', amber: 'A', cyan: 'B', blue: 'B', green: 'G', magenta: 'M', red: 'R', yellow: 'Y', grey: 'E', gray: 'E' };
        const n = color.toString().toLowerCase();
        return map[n] || color.toUpperCase().charAt(0) || 'W';
    }

    // -------------------------------------------------------------------------
    // LEDs
    // -------------------------------------------------------------------------

    setLED(ledId, brightness) {
        if (typeof ledId === 'string') ledId = LEDS[ledId.toUpperCase()] || 0;
        const data = [0x02, 0x32, 0xbb, 0, 0, 3, 0x49, ledId, brightness, 0, 0, 0, 0, 0];
        this._write(data);
    }

    setAllLEDs(ledsObj) {
        if (typeof ledsObj === 'object') {
            for (const [name, value] of Object.entries(ledsObj)) {
                let brightness;
                if (typeof value === 'boolean') brightness = value ? 255 : 0;
                else if (typeof value === 'number') brightness = Math.max(0, Math.min(255, value));
                else brightness = 0;
                this.setLED(name, brightness);
            }
        } else {
            for (const id of Object.values(LEDS)) {
                this.setLED(id, ledsObj);
            }
        }
    }

    // -------------------------------------------------------------------------
    // Button reading
    // -------------------------------------------------------------------------

    startButtonReading(callback, pollIntervalMs) {
        this.buttonCallback = callback;
        // readTimeout(0): returns immediately, does NOT set O_NONBLOCK on the fd
        // (avoids EAGAIN during updateDisplay bursts)
        this._buttonPollInterval = setInterval(() => {
            try {
                let data;
                while ((data = this._hidDevice.readTimeout(0)) && data.length >= 13) {
                    if (data[0] === 0x01) {
                        this._processButtonData(data);
                    }
                }
            } catch (e) {
                if (e.message && !e.message.includes('timeout')) {
                    console.error('[HID] button read error:', e.message);
                }
            }
        }, pollIntervalMs || 50);
    }

    _processButtonData(data) {
        const buttonBytes = data.slice(1, 13);
        const currentlyPressed = new Set();
        for (let byteIdx = 0; byteIdx < 12; byteIdx++) {
            for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
                if (buttonBytes[byteIdx] & (1 << bitIdx)) {
                    currentlyPressed.add(byteIdx * 8 + bitIdx);
                }
            }
        }
        // Edge detection: only report buttons that just transitioned to pressed
        const newlyPressed = [];
        for (const btn of currentlyPressed) {
            if (!this._previouslyPressed.has(btn)) {
                newlyPressed.push(btn);
            }
        }
        this._previouslyPressed = currentlyPressed;
        if (newlyPressed.length > 0 && this.buttonCallback) {
            this.buttonCallback(newlyPressed);
        }
    }

    stopButtonReading() {
        if (this._buttonPollInterval) {
            clearInterval(this._buttonPollInterval);
            this._buttonPollInterval = null;
        }
        this.buttonCallback = null;
    }

    // -------------------------------------------------------------------------
    // Close
    // -------------------------------------------------------------------------

    close() {
        this.stopButtonReading();
        if (this._hidDevice) {
            this._hidDevice.close();
            this._hidDevice = null;
        }
        console.log('Device closed');
    }
}

module.exports = { MCDU, COLORS, LEDS };
