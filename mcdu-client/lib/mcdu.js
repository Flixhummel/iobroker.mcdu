/**
 * MCDU Driver FINAL - Full-screen buffer approach
 * Based on https://github.com/alha847/winwing_mcdu
 * 
 * Writes ENTIRE 14-line display at once, then splits into 63-byte chunks
 */

const HID = require('node-hid');

const VENDOR_ID = 0x4098;
const PRODUCT_ID = 0xbb36;

const PAGE_LINES = 14;
const PAGE_CHARS_PER_LINE = 24;

const COLORS = {
    'L': 0x0000,
    'A': 0x0021,
    'W': 0x0042,
    'B': 0x0063,
    'G': 0x0084,
    'M': 0x00A5,
    'R': 0x00C6,
    'Y': 0x00E7,
    'E': 0x0108,
};

const LEDS = {
    BACKLIGHT: 0,
    SCREEN_BACKLIGHT: 1,
    FAIL: 8,
    FM: 9,
    MCDU: 10,
    MENU: 11,
    FM1: 12,
    IND: 13,
    RDY: 14,
    STATUS: 15,
    FM2: 16,
};

class MCDU {
    constructor() {
        this.device = null;
        this.buttonCallback = null;
        // Page buffer: 14 lines of text
        this.page = this._createEmptyPage();
        // Color buffer: 14 lines × 24 chars of colors (per-character)
        this.colors = this._createEmptyColorBuffer();
    }
    
    _createEmptyColorBuffer() {
        const buffer = [];
        for (let i = 0; i < PAGE_LINES; i++) {
            buffer.push(Array(PAGE_CHARS_PER_LINE).fill('W'));
        }
        return buffer;
    }

    _createEmptyPage() {
        const page = [];
        for (let i = 0; i < PAGE_LINES; i++) {
            page.push(' '.repeat(PAGE_CHARS_PER_LINE));
        }
        return page;
    }

    connect() {
        try {
            this.device = new HID.HID(VENDOR_ID, PRODUCT_ID);
            console.log('✓ Connected to MCDU-32-CAPTAIN');
            return true;
        } catch (err) {
            console.error('✗ Failed to connect:', err.message);
            return false;
        }
    }

    initDisplay() {
        console.log('Initializing display...');
        
        const initPackets = [
            [0xf0, 0x0, 0x1, 0x38, 0x32, 0xbb, 0x0, 0x0, 0x1e, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x18, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x34, 0x0, 0x18, 0x0, 0xe, 0x0, 0x18, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x2, 0x38, 0x0, 0x0, 0x0, 0x1, 0x0, 0x5, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0xc4, 0x24, 0xa, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x1, 0x0, 0x6, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x3, 0x38, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0xff, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x4, 0x38, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0xff, 0xff, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0xff, 0x0, 0xff, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x5, 0x38, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0xff, 0x63, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x6, 0x38, 0xff, 0xff, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x7, 0x38, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x42, 0x5c, 0x61, 0xff, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x8, 0x38, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x77, 0x77, 0x77, 0xff, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e, 0x73, 0x79, 0xff, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x9, 0x38, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xa5, 0xff, 0xff, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xa, 0x38, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0xff, 0xff, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xb, 0x38, 0xff, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x3d, 0xff, 0x0, 0xff, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xc, 0x38, 0x0, 0x3, 0x0, 0xff, 0x63, 0xff, 0xff, 0x14, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0xff, 0xff, 0x15, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xd, 0x38, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0xff, 0xff, 0xff, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x42, 0x5c, 0x61, 0xff, 0x17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xe, 0x38, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x77, 0x77, 0x77, 0xff, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x3, 0x0, 0x5e, 0x73, 0x79, 0xff, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0xf, 0x38, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x10, 0x38, 0x1b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x19, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x4, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x32, 0xbb, 0x0, 0x0, 0x1a, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
            [0xf0, 0x0, 0x11, 0x12, 0x2, 0x32, 0xbb, 0x0, 0x0, 0x1c, 0x1, 0x0, 0x0, 0x76, 0x72, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
        ];

        initPackets.forEach(packet => {
            this.device.write(Buffer.from(packet));
        });

        console.log('✓ Display initialized');
    }

    /**
     * Set text on a specific line (updates page buffer)
     * Supports both single-color and multi-color segments
     * 
     * @param {number} lineNum - Line number (0-13)
     * @param {string|array} textOrSegments - Either text string or array of {text, color} segments
     * @param {string} color - Default color if textOrSegments is a string
     */
    setLine(lineNum, textOrSegments, color = 'W') {
        if (lineNum < 0 || lineNum >= PAGE_LINES) return;
        
        // Check if segments mode (array of {text, color})
        if (Array.isArray(textOrSegments)) {
            this._setLineSegments(lineNum, textOrSegments);
        } else {
            // Simple mode: single color for entire line
            const padded = (textOrSegments + ' '.repeat(PAGE_CHARS_PER_LINE)).substring(0, PAGE_CHARS_PER_LINE);
            this.page[lineNum] = padded;
            
            // Set all characters to same color
            const normalizedColor = this._normalizeColor(color);
            for (let i = 0; i < PAGE_CHARS_PER_LINE; i++) {
                this.colors[lineNum][i] = normalizedColor;
            }
        }
    }
    
    /**
     * Set line with multiple color segments
     * @param {number} lineNum - Line number (0-13)
     * @param {array} segments - Array of {text, color} objects
     */
    _setLineSegments(lineNum, segments) {
        let text = '';
        let charIdx = 0;
        
        // Build text and color buffer from segments
        for (const segment of segments) {
            const segmentText = segment.text || '';
            const segmentColor = this._normalizeColor(segment.color || 'W');
            
            for (let i = 0; i < segmentText.length && charIdx < PAGE_CHARS_PER_LINE; i++) {
                text += segmentText[i];
                this.colors[lineNum][charIdx] = segmentColor;
                charIdx++;
            }
        }
        
        // Pad remaining characters with spaces (white)
        while (charIdx < PAGE_CHARS_PER_LINE) {
            text += ' ';
            this.colors[lineNum][charIdx] = 'W';
            charIdx++;
        }
        
        this.page[lineNum] = text;
    }
    
    /**
     * Convert color names to single-letter codes
     */
    _normalizeColor(color) {
        const colorMap = {
            'white': 'W',
            'amber': 'A',
            'cyan': 'B',
            'green': 'G',
            'magenta': 'M',
            'red': 'R',
            'yellow': 'Y',
            'grey': 'E',
            'gray': 'E'
        };
        
        const normalized = color.toString().toLowerCase();
        return (colorMap[normalized] || color.toUpperCase().charAt(0) || 'W');
    }

    /**
     * Update the display with current page buffer
     * Sends ALL 14 lines at once
     */
    updateDisplay() {
        const tmpArray = [];
        
        // Build entire display buffer (14 lines × 24 chars) with per-character colors
        for (let lineIdx = 0; lineIdx < this.page.length; lineIdx++) {
            const line = this.page[lineIdx];
            
            for (let charIdx = 0; charIdx < PAGE_CHARS_PER_LINE; charIdx++) {
                // Get color for this specific character
                const colorCode = COLORS[this.colors[lineIdx][charIdx]] || COLORS.W;
                const dataLow = colorCode & 0xFF;
                const dataHigh = (colorCode >> 8) & 0xFF;
                
                tmpArray.push(dataLow, dataHigh, line.charCodeAt(charIdx));
            }
        }
        
        // Pad to multiple of 63 bytes
        const currLength = tmpArray.length;
        if (currLength % 63 !== 0) {
            const padLength = Math.ceil(currLength / 63) * 63 - currLength;
            tmpArray.push(...Array(padLength).fill(0x00));
        }
        
        // Split into 63-byte chunks, add 0xf2 header
        for (let i = 0; i < tmpArray.length; i += 63) {
            const chunk = [0xf2, ...tmpArray.slice(i, i + 63)];
            this.device.write(Buffer.from(chunk));
        }
    }

    /**
     * Clear entire display
     */
    clear() {
        this.page = this._createEmptyPage();
        this.colors = this._createEmptyColorBuffer();
        this.updateDisplay();
    }

    setLED(ledId, brightness) {
        if (typeof ledId === 'string') {
            ledId = LEDS[ledId.toUpperCase()] || 0;
        }
        
        const data = [0x02, 0x32, 0xbb, 0, 0, 3, 0x49, ledId, brightness, 0, 0, 0, 0, 0];
        this.device.write(Buffer.from(data));
    }

    setAllLEDs(ledsObj) {
        // Accept object like {BACKLIGHT: true, RDY: 128, ...}
        if (typeof ledsObj === 'object') {
            Object.keys(ledsObj).forEach(ledName => {
                const value = ledsObj[ledName];
                let brightness;
                
                if (typeof value === 'boolean') {
                    // Boolean: true=255, false=0
                    brightness = value ? 255 : 0;
                } else if (typeof value === 'number') {
                    // Numeric: 0-255
                    brightness = Math.max(0, Math.min(255, value));
                } else {
                    brightness = 0;
                }
                
                this.setLED(ledName, brightness);
            });
        } else {
            // Legacy: single brightness value for all LEDs
            const brightness = ledsObj;
            Object.values(LEDS).forEach(ledId => {
                this.setLED(ledId, brightness);
            });
        }
    }

    startButtonReading(callback) {
        this.buttonCallback = callback;
        
        this.device.on('data', (data) => {
            if (data[0] === 0x01 && data.length >= 13) {
                const buttonBytes = data.slice(1, 13);
                
                const pressed = [];
                for (let byteIdx = 0; byteIdx < 12; byteIdx++) {
                    for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
                        if (buttonBytes[byteIdx] & (1 << bitIdx)) {
                            pressed.push(byteIdx * 8 + bitIdx);
                        }
                    }
                }
                
                if (pressed.length > 0 && this.buttonCallback) {
                    this.buttonCallback(pressed);
                }
            }
        });
    }

    /**
     * Stop button reading and clean up the HID read thread.
     * MUST be called before close() or process exit to prevent
     * node-hid read thread from corrupting the USB endpoint state.
     */
    stopButtonReading() {
        if (this.device) {
            this.device.removeAllListeners('data');
            try {
                this.device.setNonBlocking(1);
            } catch (e) {
                // may fail if device already closed
            }
        }
        this.buttonCallback = null;
    }

    close() {
        this.stopButtonReading();
        if (this.device) {
            this.device.close();
            this.device = null;
            console.log('Device closed');
        }
    }
}

module.exports = { MCDU, COLORS, LEDS };
